using Migrator.Utils;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Resources;
using System.Text;
using System.Transactions;

namespace Migrator.DatabaseMigration
{

    /// <summary>
    /// Manages migration script execution.
    /// <see cref="SqlCmdResources"/> contains sqlcmd.exe and it's 2 dependencies.  They could be moved to a better place; this works for now.  I got them from an SSMS 2018 install.
    /// <see cref="SCRIPT_RESOURCE_FILE_NAME"/> is the resource containing migration scripts.
    /// Using basic ADO to connect to database to keep simple; only one table and a few columns to interact with.
    /// </summary>
    internal class SqlCmd: IDisposable
    {

        /// <summary>
        /// :Configure: set database journal table/column names.
        /// If *every* script we ran was one generated by DacFx, we could find the database name, but ad-hoc scripts are allowed, and we still wouldn't have the column names.
        /// </summary>
        private const string TABLE_NAME = "MigrationsJournal";
        private const string SCRIPT_NAME_COLUMN = "ScriptName";
        private const string SCRIPT_BEGUN_COLUMN = "AppliedAttempted";
        private const string SCRIPT_COMPLETED_COLUMN = "AppliedCompleted";

        /// <summary>
        /// Embedded resource file
        /// </summary>
        private const string SCRIPT_RESOURCE_FILE_NAME = "DatabaseMigrationScripts.resources";
        private string _fullyQualifiedScriptResourceName = $"{nameof(Migrator)}.{nameof(DatabaseMigration)}.{SCRIPT_RESOURCE_FILE_NAME}";
        private string _sqlCmdDir;
        private string _scriptResourceFilePath;
        private readonly HashSet<string> _failedScripts = new HashSet<string>();
        private readonly SqlConnection _connection = new SqlConnection();
        private string _server;
        private string _database;
        private string _connectionString;

        /// <summary>
        /// Used to execute scripts in our DatabaseScripts resource
        /// </summary>
        /// <param name="connectionStr"></param>
        internal void Execute(string connectionStr)
        {
            SetConnectionStrings(connectionStr);
            CreateSqlCmdDir();
            var sqlCmdPath = Path.Combine(_sqlCmdDir, $"{nameof(SqlCmd)}.exe");
            if (ExtractScriptResourceFile())
            {
                if (OpenConnection())
                {
                    foreach ((string name, object value) resource in GetResources(true))
                    {
                        var filePath = WriteResourceToFile(resource);
                        if (ShouldExecute(resource.name))
                        {
                            CreateProcessFor(sqlCmdPath, filePath);
                            if (!RecordScriptInJournal(resource.name, false))
                            {
                                break; // logged
                            }
                        }
                        else
                        {
                            // :Configure: Log
                            Console.WriteLine($"Skipping script [{resource.name}]; already executed or may be in process from another client.");
                        }
                    }
                }
            }
        }

        private bool OpenConnection()
        {
            _connection.ConnectionString = _connectionString;
            try
            {
                _connection.Open();
                return true;
            }
            catch (Exception ex) // when (ex is ArgumentException || ex is SqlException)
            {
                // :Configure: log
                Console.WriteLine($"Connection failed; unable to apply migrations.");
                return false;
            }
        }

        /// <summary>
        /// Add a record that a script is being (begin true) or has completed (begin false) executed.
        /// </summary>
        /// <param name="scriptName">The file name portion (including extension) of the script (the key of the script in the resource file).  Case insensitive.</param>
        /// <returns>Pass/fail</returns>
        private bool RecordScriptInJournal(string scriptName, bool begin, SqlTransaction transaction = null)
        {
            var result = true;

            if (begin)
            {
                DeletePriorEntry(scriptName, transaction);
            }
            else if (_failedScripts.Contains(scriptName))
            {
                return result; // Don't update as passed because we captured failure.
            }

            var commandText = begin ? $"insert {TABLE_NAME}({SCRIPT_NAME_COLUMN}, {SCRIPT_BEGUN_COLUMN}) values ('{scriptName}', GetDate())" : $"update {TABLE_NAME} set {SCRIPT_COMPLETED_COLUMN} = 1 where {SCRIPT_NAME_COLUMN} = '{scriptName}'";
            using (var cmd = new SqlCommand(commandText, _connection, transaction))
            {
                try
                {
                    cmd.ExecuteNonQuery();
                }
                catch (SqlException ex)
                {
                    result = false;
                    // :Configure: log
                    Console.WriteLine($"Error adding or updating migration journal record: {ex.Message}");
                }
            }

            return result;
        }

        /// <summary>
        /// Remove any prior record for this script (for a script that began but didn't finish).
        /// </summary>
        /// <param name="scriptName">The file name portion (including extension) of the script (the key of the script in the resource file).  Case insensitive.</param>
        private void DeletePriorEntry(string scriptName, SqlTransaction transaction)
        {
            using (var cmd = new SqlCommand($"delete from {TABLE_NAME} where {SCRIPT_NAME_COLUMN} = '{scriptName}'", _connection, transaction))
            {
                try
                {
                    cmd.ExecuteNonQuery();
                }
                catch (SqlException)
                {
                    ; // continue anyway
                }
            }
        }

        /// <summary>
        /// Determine whether we should execute the current script by checking the migration journal table.
        /// Side effect is that it adds a record to the journal table (unless an old one was already present) if it returns true.
        /// </summary>
        /// <param name="scriptName">The key to the script in the script resource.</param>
        /// <returns>True if the current script hasn't already been executed or is assumed to have failed in a prior run (<see cref="ScriptFailedInPriorRun"/>)</returns>
        /// <remarks>Assumption: we are running in a security context that has access to the database.</remarks>
        private bool ShouldExecute(string scriptName)
        {
            Debug.Assert(_connection.State == ConnectionState.Open);
            // :Configure: log
            void LogError(Exception e) => Console.WriteLine($"Error checking database to determine whether script has already run: {e.Message}");
            var result = false;
            
            /// We need to ensure that we check for the presence of the record and (if good) add the record in one transaction
            /// otherwise another instance may check in the meantime and we both start the script.
            var transaction = _connection.BeginTransaction(System.Data.IsolationLevel.Serializable);
            var commit = true;
            try
            {
                // Explicit table lock hint.  Not often used, maybe I'm re-inventing a queue here, so be it.
                using (var cmd = new SqlCommand($"select * from {TABLE_NAME} (TABLOCKX) where {SCRIPT_NAME_COLUMN} = '{scriptName}'", _connection, transaction))
                {
                    try
                    {
                        using (var reader = cmd.ExecuteReader(CommandBehavior.SingleResult))
                        {
                            if (!reader.HasRows || ScriptFailedInPriorRun(reader))
                            {
                                reader.Close(); // must close before write.
                                result = RecordScriptInJournal(scriptName, true, transaction);
                            }
                        }
                    }
                    catch (SqlException ex)
                    {
                        commit = false;
                        LogError(ex);
                    }
                    finally
                    {
                        if (commit)
                        {
                            transaction.Commit();
                        }
                        else
                        {
                            transaction.Rollback();
                        }
                    }
                }
            }
            catch (TransactionAbortedException ex)
            {
                LogError(ex);
            }

            return result;
        }

        static bool ScriptFailedInPriorRun(SqlDataReader reader)
        {
            var result = false;
            reader.Read();
            if (bool.TryParse(reader[SCRIPT_COMPLETED_COLUMN].ToString(), out var scriptCompleted))
            {
                if (!scriptCompleted)
                {
                    if (DateTime.TryParse(reader[SCRIPT_BEGUN_COLUMN].ToString(), out var dateAttempted))
                    {
                        /// Multiple clients can start up and begin executing scripts.
                        /// We're going to assume that if a row exists that indicated a start to the script, but scriptCompleted is false and the date of the attempt is
                        /// more than an hour ago, we have a failed execution.
                        /// Otherwise, another client may be normally executing the script.
                        return (DateTime.Now - dateAttempted) > TimeSpan.FromHours(1);
                    }
                }
            }
            return result;
        }

        /// <summary>
        /// Start up sqlcmd.exe and execute the script
        /// </summary>
        /// <remarks>Process start inherits the security context of the parent process.</remarks>
        private void CreateProcessFor(string sqlcmdPath, string scriptPath)
        {
            var scriptFileName = Path.GetFileName(scriptPath);
            // :Configure: log
            Console.WriteLine($"Executing script {scriptFileName}");

            var psi = new ProcessStartInfo
            {
                CreateNoWindow = true,
                ErrorDialog = false,
                FileName = sqlcmdPath,  // If sqlcmd were installed proper, it would be on path and we could simply pass "SQLCMD"
                UseShellExecute = false,
                Arguments = $"-i {scriptPath} -S {_server}",
                RedirectStandardError = true,
                RedirectStandardOutput = true,
                StandardErrorEncoding = Encoding.UTF8,
                StandardOutputEncoding = Encoding.UTF8,
            };

            try
            {
                using (var process = new Process { StartInfo = psi })
                {
                    process.Start();
                    process.ErrorDataReceived += (sender, e) =>
                    {
                        /// Unfortunately this seems to fire with null data for passing and failing scripts.
                        /// Doesn't hurt; it's possible it will pass valid error content.
                        if (e.Data != null)
                        {
                            // :Configure: log.
                            Console.WriteLine(e.Data);
                            _failedScripts.Add(scriptFileName);
                        }
                    };
                    // :Configure: log.
                    process.OutputDataReceived += (sender, e) => Console.WriteLine(e.Data);
                    process.BeginErrorReadLine();
                    process.BeginOutputReadLine();
                    process.WaitForExit(20000); // this doesn't halt.
                }
            }
            catch (Exception ex)
            {
                // :Configure: log.
                Console.WriteLine($"Unable to create process for updating database: {ex.Message}");
                throw;
            }
        }

        /// <summary>
        /// Write out the resource file to the same directory we're using for sqlcmd.exe and set the field holding it's path.
        /// We have to write out the resource file so we can read it using the standard library object (and we're already managing files anyway).
        /// </summary>
        /// <returns>pass/fail</returns>
        private bool ExtractScriptResourceFile()
        {
            var result = false;
            using (Stream scriptResourceStream = Assembly.GetExecutingAssembly().GetManifestResourceStream(_fullyQualifiedScriptResourceName))
            {
                if (scriptResourceStream == null)
                {
                    // :Configure: log
                    Console.WriteLine($"Expected resource stream {_fullyQualifiedScriptResourceName} in assembly {Assembly.GetExecutingAssembly().FullName}");
                }
                else
                {
                    _scriptResourceFilePath = Path.Combine(_sqlCmdDir, SCRIPT_RESOURCE_FILE_NAME);
                    result = FileUtils.StreamToFile(scriptResourceStream, _scriptResourceFilePath);
                }
            }
            return result;
        }

        /// <summary>
        /// Streams out sqlcmd and it's 2 dependencies.
        /// </summary>
        /// <remarks>Sets class var that is path to temp dir.</remarks>
        private void CreateSqlCmdDir()
        {
            _sqlCmdDir = Path.Combine(Path.GetTempPath(), nameof(SqlCmd));
            DirectoryUtils.FlushDirectory(_sqlCmdDir, true); // in case left over from previous run.
            Directory.CreateDirectory(_sqlCmdDir);
            foreach (var resource in GetResources(false))
            {
                WriteResourceToFile(resource);
            }
        }

        /// <summary>
        /// Write out the actual content (a binary or a script) that has been extracted from the resource.
        /// </summary>
        /// <param name="resource">Result of call to <see cref="GetResources"/> </param>
        private string WriteResourceToFile((string name, object value) resource)
        {
            var filePath = Path.Combine(_sqlCmdDir, resource.name);  // expected that the key is the file name.
            if (resource.value is string)
            {
                File.WriteAllText(filePath, (string)resource.value, Encoding.UTF8);
            }
            else
            {
                File.WriteAllBytes(filePath, (byte[])resource.value);
            }
            return filePath;
        }

        /// <summary>
        /// Get either the executable resource for sqlcmd or actual scripts from the script resource file.
        /// </summary>
        /// <param name="scripts">True if you're asking for script resources; false if you want the actual sqlcmd.exe resources.</param>
        /// <returns>key name, resource value (either a string or a byte array)</returns>
        private IEnumerable<(string name, object value)> GetResources(bool scripts)
        {
            // We get different resources a bit differently.
            IEnumerable<DictionaryEntry> GetResources()
            {
                if (scripts)
                {
                    using (var reader = new ResourceReader(_scriptResourceFilePath))
                    {
                        foreach (DictionaryEntry item in reader)
                        {
                            yield return item;
                        }
                    }
                }
                else
                {
                    foreach (DictionaryEntry item in SqlCmdResources.ResourceManager.GetResourceSet(CultureInfo.InvariantCulture, true, true))
                    {
                        yield return item;
                    }
                }
            }

            foreach (DictionaryEntry item in GetResources())
            {
                yield return ((string)item.Key, item.Value);
            }
        }

        private void SetConnectionStrings(string connectionStr)
        {
            var connectionStringBuilder = new SqlConnectionStringBuilder(connectionStr);
            _connectionString = connectionStr;
            _server = connectionStringBuilder.DataSource;
            _database = connectionStringBuilder.InitialCatalog;

        }

        public void Dispose()
        {
            if (Directory.Exists(_sqlCmdDir))
            {
                DirectoryUtils.FlushDirectory(_sqlCmdDir, true);
            }
            if (_connection.State == ConnectionState.Open)
            {
                _connection.Close();
            }
        }

    }

}
