<#
	• Looks for scripts in Migrations & AdHoc directory to add to the resource file in the console app.  Also updates the known file DatabaseState.dacpac to the current state.
    Migrations will be added to resource and added to the database journal table; assumes developer has already made these changes.
    AdHoc will be added to resource and NOT added to the database journal table; assumes developer has written the script but wants it to executed upon next startup of console.
    Scripts in AdHoc will have their project reference deleted after processing if they were added via project right-click.
	• Check :Configure: for things to change when plugging into another solution.
	• Every reference to "$dte" is a dependency on visual studio.  The whole thing could be independent of vs, but it's much easier this way and more convenient to run it.
#>

Import-Module "$PSScriptRoot\Common.psm1" #-Force

$global:MigrationTableName = 'MigrationsJournal'
$global:MigrationTableScriptNameColumn = 'ScriptName'
$global:MigrationTableAppliedAttemptedColumn = 'AppliedAttempted'
$global:MigrationTableAppliedCompletedColumn = 'AppliedCompleted'
# :Configure: Adjust as necessary.  Assumes all devs can share same local connection string.
$global:conStr = "Server=.\SQLEXPRESS;Database=$global:DatabaseProjectName;Trusted_Connection=Yes"
# Set after determining solution root
$global:ResourceFilePath = ''
$global:ResourceFileBackupPath = ''
$global:MigrationScriptPath = ''
$global:AdHocScriptPath = ''
$global:JournalTableCreationScriptPath = ''
# :Configure: Your service project name in place of "Migrator."  This file begins as empty resource file generated by `new ResourceWriter()`
#             Use Empty.resources as a reset/starting point.
$global:ResourceFileRelativePath = 'Migrator\DatabaseMigration\DatabaseMigrationScripts.resources'
$global:NewResources = @()
$global:NextScriptKey = 0

# Caller must close the connection
function get-open-connection() {
    try {
        $result = New-Object System.Data.SqlClient.SqlConnection
        $result.ConnectionString = $global:conStr
        $result.Open()
        $result
    }
    catch {
        Write-Host $_ -ForegroundColor Red
        exit # Without this the script may keep going
    }
}

# Assumes open connection
function get-command([System.Data.SqlClient.SqlConnection] $con, [string] $cmdText) {
    $result = New-Object System.Data.SqlClient.SqlCommand
    $result.CommandText = $cmdText
    $result.Connection = $con
    $result
}

# Caller must clean up
function GetResourceWriter {
    New-Object System.Resources.ResourceWriter -ArgumentList $global:ResourceFilePath
}

# Caller must clean up
function GetResourceReader {
    New-Object System.Resources.ResourceReader -ArgumentList $global:ResourceFileBackupPath
}

<#
.DESCRIPTION
Script resource keys are ordered except our pre-required create journal script.  This gets the next key (int) to use based on the resources we already have.
LoadExistingResources must have been called first.
#>
function GetNextScriptKey {
    Write-Host "Counting scripts in $global:ResourceFilePath" -ForegroundColor Blue
    $r = GetResourceReader
    try {
        $junkref = 0
        # you can't split pipes.  Much sadness.
        # Find the max of all keys where the key converts to int
        $max = ($r | Where-Object { [int]::TryParse($_.Key, [ref] $junkref) } | Select-Object -ExpandProperty Key | ForEach-Object { [System.Convert]::ToInt32($_) } | Measure-Object -Max).Maximum
        # Leave it at this number because the call to add a new script will increment it.
        if ($null -eq $max) {
            $max = 0
        }
        Write-Host "Counted $max existing scripts." -ForegroundColor Blue
        $max
    }
    finally {
        $r.Close() > $null
    }
}

<#
.DESCRIPTION
Adds a row to the script/log table for the current developer
Pre: Assumes developer has already made the database changes for his/her database instance.
      GenerateDiffScript has run and left a script in the migration folder, or someone has added script(s) to the AdHoc folder.
#>
function AddTableEntry {
    Write-Host "Adding record to database migration table for script #$global:NextScriptKey" -ForegroundColor Blue
    try {
        $con = get-open-connection
        $cmd = get-command $con "insert $global:MigrationTableName($global:MigrationTableScriptNameColumn, $global:MigrationTableAppliedAttemptedColumn, $global:MigrationTableAppliedCompletedColumn) values ('$global:NextScriptKey', GetUtcDate(), 1)"
        $cmd.ExecuteNonQuery() > $null
        $con.Close() > $null
    }
    catch {
        Write-Host "Error (below) adding entry to table MigrationsJournal.  System.Data.SqlClient not present?" -ForegroundColor Red
        Write-Host $_ -ForegroundColor Red
        exit # Without this the script may keep going
    }
}

<#
.DESCRIPTION
Takes the latest build from BuildDacPac and overwrites ./DatabaseState.dacpac with that.
Pre: GenerateDiffScript has run.
#>
function UpdateDatabaseStateDacPac {
    try {
        Write-Host "Updating database state file [$global:SourceDacPath] -> [$global:TargetDacPath]." -ForegroundColor Blue
        [System.IO.File]::Delete($global:TargetDacPath) > $null
        # Copy from output dir to project location.
        [System.IO.File]::Copy($global:SourceDacPath, $global:TargetDacPath) > $null
    }
    catch {
        Write-Host $_ -ForegroundColor Red
        exit # Without this the script may keep going
    }
}

function TestScriptRelatedPaths {
    # dunno how to chain these
    Write-Host "Testing script related paths." -ForegroundColor Blue
    if (Test-Path $global:MigrationScriptPath) {
        if (Test-Path $global:AdHocScriptPath) {
            if (Test-Path $global:ResourceFilePath) {
                if (Test-Path $global:JournalTableCreationScriptPath) {
                    $true
                }
                else {
                    throw "Expected to find journal table creation script: $global:JournalTableCreationScriptPath"
                }
            }
            else {
                throw "Expected to find resource file: $global:ResourceFilePath"
            }
        }
        else {
            throw "Migration script path invalid: $global:MigrationScriptPath"
        }
    }
    else {
        throw "AdHoc script path invalid: $global:AdHocScriptPath"
    }
}

# Pre: EnsureDatabaseProjectSelected & SetProjectBasedGlobals have been called.
function set-script-source-paths {
    $global:MigrationScriptPath = "$global:DatabaseProjRootPath\Scripts\Migrations"
    $global:AdHocScriptPath = "$global:DatabaseProjRootPath\Scripts\AdHoc"
    $global:ResourceFilePath = "$global:SolutionRootDir\$global:ResourceFileRelativePath"
    $global:ResourceFileBackupPath = "$global:ResourceFilePath.bak"
    $global:JournalTableCreationScriptPath = "$global:DatabaseProjRootPath\Scripts\$global:MigrationTableName.sql"
}

<#
.DESCRIPTION
Adds script at path passed in to the collection of resources $global:NewResources
#>
function AddToResource([string] $scriptPath, [bool]$adHoc = $False) {
    $global:NextScriptKey = $global:NextScriptKey + 1
    Write-Host "Adding $scriptPath as script #$global:NextScriptKey" -ForegroundColor Blue
    try {
        $scriptContent = Get-Content -Path $scriptPath -Delimiter '\0'
        if ($adHoc) {
            # For ad-hoc scripts add a using statement to set the database so we don't have to require fully qualified database object names.
            $scriptContent = "use [$global:DatabaseProjectName];$([System.Environment]::NewLine)$scriptContent"
        }
        $global:NewResources += @{ Key = ($global:NextScriptKey).ToString(); Value = $scriptContent }
    } 
    catch {
        Write-Host $_ -ForegroundColor Red
        exit # Without this the script may keep going
    }
}

<#
.DESCRIPTION
Journal table must be present when committing scripts.  This is because it's assumed that the developer running this script has already made database changes; they should not be Applied
to his database instance at next service startup.  AdHoc scripts will in fact be applied, but for the developer, this table should already be present.
Note that the journal table doesn't have to be present for the service.  So a new developer or a new service instance in another environment could be started up
without the journal table and it would be the first thing created.
#>
function EnsureJournalTablePresent {
    Write-Host "Ensuring Journal Table is present." -ForegroundColor Blue
    $con = get-open-connection
    try {
        $cmd = get-command $con "select 1 from sys.tables where name = '$global:MigrationTableName'"
        $reader = $cmd.ExecuteReader()
        $reader.Read() > $null
        $reader.HasRows
    }
    finally {
        $cmd.Dispose() > $null
        $con.Dispose() > $null
    }
}

function EnsureJournalScriptPresent {
    if ($global:NextScriptKey -eq 0) {
        Write-Host "No existing scripts found.  Adding journal table creation script as first." -ForegroundColor Blue
        AddToResource $global:JournalTableCreationScriptPath $True
    }
}

<#
.DESCRIPTION
Write out new resources we've loaded to $global:ResourceFilePath
#>
function FlushResourcesToResourceFile() {
    $writer = GetResourceWriter
    try {
        Write-Host "Writing existing scripts to resource file." -ForegroundColor Blue
        CopyExistingResourcesToResourceFile $writer
        Write-Host "Writing new scripts to resource file." -ForegroundColor Blue
        $global:NewResources | ForEach-Object { $writer.AddResource($_.Key, $_.Value) }
    } 
    catch {
        Write-Host $_ -ForegroundColor Red
        exit # Without this the script may keep going
    }
    finally {
        $writer.Close() > $null
    }
}

<#
.DESCRIPTION
Write out the resources that existed prior to execution (that we wrote to a .bak file).
This must be called in the context of FlushResourcesToResourceFile because that's where the writer is opened.
#>
function CopyExistingResourcesToResourceFile([System.Resources.ResourceWriter] $writer) {
    $r = GetResourceReader
    try {
        $r | ForEach-Object { $writer.AddResource($_.Key, $_.Value) }
    }
    finally {
        $r.Close() > $null
    }
}

<#
.DESCRIPTION
Process $global:MigrationScriptPath.
Expected; 0 (may be running this script just for AdHoc) or 1 file.  If multiples, we assume something went wrong with previous run; probably should've deleted?
#>
function ProcessMigrationDirectory {
    Write-Host "Processing scripts in $global:MigrationScriptPath" -ForegroundColor Blue
    try {
        $scriptCount = (Get-Childitem $global:MigrationScriptPath | Measure-Object).Count
        if ($scriptCount -gt 1) {
            throw "Expected 0 or 1 file.  Was a previous state migration file not processed correctly, or did you mean to delete a previously generated script?"
            exit
        }
        else {
            if ($scriptCount -eq 1) {
                $scriptPath = (Get-Childitem -Path $global:MigrationScriptPath).FullName | Select-Object -First 1
                AddToResource $scriptPath
                AddTableEntry
                UpdateDatabaseStateDacPac
                Remove-Item $scriptPath
            }
        }
    } 
    catch {
        Write-Host $_ -ForegroundColor Red
        exit # Without this the script may keep going
    }
}

<#
.DESCRIPTION
Given $databaseProjectItem (a reference to the database project), drill down into known folders and find the script that may exist there.
#>
function FindScriptInProjectItems($databaseProjectItem, $scriptName) {
    $result = $databaseProjectItem | Select-Object -Expand ProjectItems | Where-Object { $_.Name -eq 'Scripts' -or $_.Name -eq 'AdHoc' -or $_.Name -eq $scriptName }
    if ($result.Name -eq $scriptName) {
        $result
    }
    if ($null -ne $result) {
        FindScriptInProjectItems $result $scriptName
    }
    # else we didn't find it.
}

<#
.DESCRIPTION
Process $global:AdHocScriptPath
Add scripts found there to known resource file.
#>
function ProcessAdHocDirectory {
    Write-Host "Processing scripts in $global:AdHocScriptPath" -ForegroundColor Blue
    try {
        Get-Childitem -Path $global:AdHocScriptPath | ForEach-Object {
            AddToResource $_.FullName $True
            # delete the file
            Remove-Item $_.FullName
            # Remove the item from the project if present.
            $databaseProjectObject = $dte.Solution.Projects | Where-Object { $_.Name -eq $global:DatabaseProjectName }
            $scriptProjectItem = FindScriptInProjectItems $databaseProjectObject $_.Name # file name only
            if ($null -ne $scriptProjectItem) {
                $scriptProjectItem.Remove() # Remove the project item so it's not an orphan
            }
        }
        FlushResourcesToResourceFile
    } 
    catch {
        Write-Host $_ -ForegroundColor Red
        exit # Without this the script may keep going
    }
}

# MAIN
EnsureDatabaseProjectSelected
SetProjectBasedGlobals
set-script-source-paths

if (TestScriptRelatedPaths) { # else error written to console
    if (EnsureJournalTablePresent) {
        Write-Host "Creating backup of existing resources to $global:ResourceFileBackupPath" -ForegroundColor Blue
        Copy-Item $global:ResourceFilePath $global:ResourceFileBackupPath # backup existing.  We can't ever add to the file with existing framework objects.
        try {
            # Get the next script nummber based on current scripts
           $global:NextScriptKey = GetNextScriptKey
            EnsureJournalScriptPresent
            ProcessMigrationDirectory
            ProcessAdHocDirectory
        }
        finally {
            Write-Host "Deleting backup resource file." -ForegroundColor Blue
            Remove-Item $global:ResourceFileBackupPath
        }
    } else {
        Write-Host "Journal table not present.  See comments at EnsureJournalTablePresent" -ForegroundColor Red
    }
}